@inproceedings{White-Bour-Yallop/Modular_Implicits/ml2014,
  author    = {Leo White and
               Fr{\'{e}}d{\'{e}}ric Bour and
               Jeremy Yallop},
  title     = {Modular implicits},
  booktitle = {Proceedings {ML} Family/OCaml Users and Developers workshops, ML/OCaml
               2014, Gothenburg, Sweden, September 4-5, 2014.},
  pages     = {22--63},
  year      = {2014},
  crossref  = {DBLP:journals/corr/KiselyovG15},
  url       = {https://doi.org/10.4204/EPTCS.198.2},
  doi       = {10.4204/EPTCS.198.2},
  timestamp = {Wed, 12 Sep 2018 01:05:15 +0200},
  biburl    = {https://dblp.org/rec/bib/journals/corr/WhiteBY15},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@proceedings{DBLP:journals/corr/KiselyovG15,
  editor    = {Oleg Kiselyov and
               Jacques Garrigue},
  title     = {Proceedings {ML} Family/OCaml Users and Developers workshops, ML/OCaml
               2014, Gothenburg, Sweden, September 4-5, 2014},
  series    = {{EPTCS}},
  volume    = {198},
  year      = {2015},
  url       = {https://doi.org/10.4204/EPTCS.198},
  doi       = {10.4204/EPTCS.198},
  timestamp = {Wed, 12 Sep 2018 01:05:15 +0200},
  biburl    = {https://dblp.org/rec/bib/journals/corr/KiselyovG15},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}



@inproceedings{Dreyer-Harper-Chakravarty-Keller/Modular_type_classes/popl2007,
  author    = {Derek Dreyer and
               Robert Harper and
               Manuel M. T. Chakravarty and
               Gabriele Keller},
  title     = {Modular type classes},
  booktitle = {Proceedings of the 34th {ACM} {SIGPLAN-SIGACT} Symposium on Principles
               of Programming Languages, {POPL} 2007, Nice, France, January 17-19,
               2007},
  pages     = {63--70},
  year      = {2007},
  crossref  = {DBLP:conf/popl/2007},
  url       = {https://doi.org/10.1145/1190216.1190229},
  doi       = {10.1145/1190216.1190229},
  timestamp = {Tue, 06 Nov 2018 11:07:42 +0100},
  biburl    = {https://dblp.org/rec/bib/conf/popl/DreyerHCK07},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@proceedings{DBLP:conf/popl/2007,
  editor    = {Martin Hofmann and
               Matthias Felleisen},
  title     = {Proceedings of the 34th {ACM} {SIGPLAN-SIGACT} Symposium on Principles
               of Programming Languages, {POPL} 2007, Nice, France, January 17-19,
               2007},
  publisher = {{ACM}},
  year      = {2007},
  url       = {http://dl.acm.org/citation.cfm?id=1190216},
  isbn      = {1-59593-575-4},
  timestamp = {Tue, 05 Nov 2013 17:32:56 +0100},
  biburl    = {https://dblp.org/rec/bib/conf/popl/2007},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}


@inproceedings{Lewis-Launchbury-Meijer-Shielfields/Implict_parameters/popl2000,
  address      = {New York, NY, USA},
  series       = {{POPL} '00},
  title        = {Implicit {Parameters}: {Dynamic} {Scoping} with {Static}
                  {Types}},
  isbn         = {1-58113-125-9},
  url          = {http://doi.acm.org/10.1145/325694.325708},
  doi          = {10.1145/325694.325708},
  booktitle    = {Proceedings of the 27th {ACM} {SIGPLAN}-{SIGACT}
                  {Symposium} on {Principles} of {Programming} {Languages}},
  publisher    = {ACM},
  author       = {Lewis, Jeffrey R. and Launchbury, John and Meijer, Erik
                  and Shields, Mark B.},
  year         = {2000},
  note         = {event-place: Boston, MA, USA},
  pages        = {108--118},
  file         = {Full Text:/Users/remy/Zotero/storage/RT3SVNLV/Lewis et
                  al. - 2000 - Implicit Parameters Dynamic Scoping with
                  Static T.pdf:application/pdf}
}

@inproceedings{Oliveira-Moors-Odersky/scala_implicits/opsla20010,
  title        = {Type classes as objects and implicits},
  url          = {https://doi.org/10.1145/1869459.1869489},
  doi          = {10.1145/1869459.1869489},
  booktitle    = {Proceedings of the 25th {Annual} {ACM} {SIGPLAN}
                  {Conference} on {Object}-{Oriented} {Programming},
                  {Systems}, {Languages}, and {Applications}, {OOPSLA} 2010,
                  {October} 17-21, 2010, {Reno}/{Tahoe}, {Nevada}, {USA}},
  author       = {Oliveira, Bruno C. d S. and Moors, Adriaan and Odersky,
                  Martin},
  year         = {2010},
  pages        = {341--360},
  file         = {Full Text:/Users/remy/Zotero/storage/2ASUEVVI/Oliveira et
                  al. - 2010 - Type classes as objects and
                  implicits.pdf:application/pdf}
}

@article{Rossberg-Dreyer/mixinup/toplas,
  title        = {Mixin'{Up} the {ML} {Module} {System}},
  volume       = {35},
  issn         = {0164-0925},
  url          = {http://doi.acm.org/10.1145/2450136.2450137},
  doi          = {10.1145/2450136.2450137},
  number       = {1},
  journal      = {ACM Trans. Program. Lang. Syst.},
  author       = {Rossberg, Andreas and Dreyer, Derek},
  month        = apr,
  year         = {2013},
  keywords     = {abstract data types, hierarchical composability, mixin
                  modules, ML modules, recursive modules, Type systems},
  pages        = {2:1--2:84},
  file         = {Full Text:/Users/remy/Zotero/storage/5E2RYPZE/Rossberg and
                  Dreyer - 2013 - Mixin'Up the ML Module
                  System.pdf:application/pdf}
}


@article{Rompf-Amin/dot/2015, 
  author    = {Tiark Rompf and
               Nada Amin},
  title     = {From {F} to {DOT:} Type Soundness Proofs with Definitional Interpreters},
  journal   = {CoRR},
  volume    = {abs/1510.05216},
  year      = {2015},
  url       = {http://arxiv.org/abs/1510.05216},
  archivePrefix = {arXiv},
  eprint    = {1510.05216},
  timestamp = {Mon, 13 Aug 2018 16:46:46 +0200},
  biburl    = {https://dblp.org/rec/bib/journals/corr/RompfA15},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{Amin-Rompf-Odersky/dot/oopsla2014,
  author       = {Amin, Nada and Rompf, Tiark and Odersky, Martin},
  title        = {Foundations of Path-dependent Types},
  booktitle    = {Proceedings of the 2014 ACM International Conference on
                  Object Oriented Programming Systems Languages \&
                  Applications},
  series       = {OOPSLA '14},
  year         = {2014},
  isbn         = {978-1-4503-2585-1},
  location     = {Portland, Oregon, USA},
  pages        = {233--249},
  numpages     = {17},
  url          = {http://doi.acm.org/10.1145/2660193.2660216},
  doi          = {10.1145/2660193.2660216},
  acmid        = {2660216},
  publisher    = {ACM},
  address      = {New York, NY, USA},
  keywords     = {calculus, dependent types, objects},
}


@article{Rossberg/1ml/jfp2018,
  title        = {1ML - {Core} and modules united},
  volume       = {28},
  url          = {https://doi.org/10.1017/S0956796818000205},
  doi          = {10.1017/S0956796818000205},
  journal      = {J. Funct. Program.},
  author       = {Rossberg, Andreas},
  year         = {2018},
  pages        = {e22},
  file         = {Rossberg - 2018 - 1ML - Core and modules
                  united.pdf:/Users/remy/Zotero/storage/4TIZE36J/Rossberg -
                  2018 - 1ML - Core and modules united.pdf:application/pdf}
}

@inproceedings{Crary/modules-parametricity/popl2017,
  author       = {Crary, Karl},
  title        = {Modules, Abstraction, and Parametric Polymorphism},
  booktitle    = {Proceedings of the 44th ACM SIGPLAN Symposium on
                  Principles of Programming Languages},
  series       = {POPL 2017},
  year         = {2017},
  isbn         = {978-1-4503-4660-3},
  location     = {Paris, France},
  pages        = {100--113},
  numpages     = {14},
  url          = {http://doi.acm.org/10.1145/3009837.3009892},
  doi          = {10.1145/3009837.3009892},
  acmid        = {3009892},
  publisher    = {ACM},
  address      = {New York, NY, USA},
  keywords     = {Abstraction, logical relations, modules, parametricity},
} 

@phdthesis{Montagu/modules/pdh2010,
  type         = {{PhD} {Thesis}},
  title        = {Programming with first-class modules in a core language
                  with subtyping, singleton kinds and open existential
                  types. ({Programmer} avec des modules de première classe
                  dans un langage noyau pourvu de sous-typage, sortes
                  singletons et types existentiels ouverts)},
  url          = {https://tel.archives-ouvertes.fr/tel-00550331},
  school       = {École Polytechnique, Palaiseau, France},
  author       = {Montagu, Benoît},
  year         = {2010},
  file         = {Full Text:/Users/remy/Zotero/storage/2F67J3ZT/Montagu -
                  2010 - Programming with first-class modules in a core
                  lan.pdf:application/pdf}
}

@inproceedings{Harper-Stone/singleton-kinds/popl2000,
  address      = {New York, NY, USA},
  series       = {{POPL} '00},
  title        = {Deciding {Type} {Equivalence} in a {Language} with
                  {Singleton} {Kinds}},
  isbn         = {1-58113-125-9},
  url          = {http://doi.acm.org/10.1145/325694.325724},
  doi          = {10.1145/325694.325724},
  booktitle    = {Proceedings of the 27th {ACM} {SIGPLAN}-{SIGACT}
                  {Symposium} on {Principles} of {Programming} {Languages}},
  publisher    = {ACM},
  author       = {Stone, Christopher A. and Harper, Robert},
  year         = {2000},
  note         = {event-place: Boston, MA, USA},
  pages        = {214--227},
  file         = {Full Text:/Users/remy/Zotero/storage/9XXVICJR/Stone and
                  Harper - 2000 - Deciding Type Equivalence in a Language
                  with Singl.pdf:application/pdf}
}

@article{Miller/pattern-unification/jlc1991,
  title        = {A {Logic} {Programming} {Language} with
                  {Lambda}-{Abstraction}, {Function} {Variables}, and
                  {Simple} {Unification}},
  volume       = {1},
  issn         = {0955-792X},
  url          = {https://doi.org/10.1093/logcom/1.4.497},
  doi          = {10.1093/logcom/1.4.497},
  abstract     = {It has been argued elsewhere that a logic programming
                  language with function variables and λ-abstractions within
                  terms makes a good meta-programming language, especially
                  when an object-language contains notions of bound
                  variables and scope. The λProlog logic programming
                  language and the related Elf and Isabelle systems provide
                  meta-programs with both function variables and
                  λ-abstractions by containing implementations of higher
                  order unification. This paper presents a logic programming
                  language, called Lλ, that also contains both function
                  variables and λ-abstractions, although certain
                  restrictions are placed on occurrences of function
                  variables. As a result of these restrictions, an
                  implementation of Lλdoes not need to implement full
                  higher-order unification. Instead, an extension to
                  first-order unification that respects bound variable names
                  and scopes is all that is required. Such unification
                  problems are shown to be decidable and to possess most
                  general unifiers when unifiers exist. A unification
                  algorithm and logic programming interpreter are described
                  and proved correct. Several examples of using Lλ as a
                  meta-programming language are presented.},
  number       = {4},
  journal      = {Journal of Logic and Computation},
  author       = {Miller, Dale},
  year         = {1991},
  pages        = {497--536},
  file         = {Full Text:/Users/remy/Zotero/storage/ZN4HN7KV/MILLER -
                  1991 - A Logic Programming Language with
                  Lambda-Abstracti.pdf:application/pdf}
}

@inproceedings{Oliveira-Schrijvers-Choi-Lee-Yi/generics/pldi2012,
  title        = {The implicit calculus: a new foundation for generic
                  programming},
  url          = {https://doi.org/10.1145/2254064.2254070},
  DOI          = {10.1145/2254064.2254070},
  booktitle    = {ACM SIGPLAN Conference on Programming Language Design and
                  Implementation, PLDI ’12, Beijing, China - June 11 - 16,
                  2012},
  publisher    = {ACM},
  author       = {Oliveira, Bruno C. d S. and Schrijvers, Tom and Choi,
                  Wontae and Lee, Wonchan and Yi, Kwangkeun},
  editor       = {Vitek, Jan and Lin, Haibo and Tip, Frank},
  year         = {2012},
  pages        = {35–44}
}

@Article{Garrigue-Remy/poly-ml,
  author       = "Jacques Garrigue and Didier R{\'e}my",
  title        = "Extending {ML} with Semi-Explicit Higher-Order
                  Polymorphism",
  journal      = "Information and Computation",
  year         = 1999,
  volume       = "155",
  number       = "1/2",
  pages        = "134--169",
  note         = "A preliminary version appeared in TACS'97",
  abstract     = {We propose a modest conservative extension to ML that
                  allows semi-explicit first-class polymorphism while
                  preserving the essential properties of type inference.  In
                  our proposal, the introduction of polymorphic types is
                  fully explicit, that is, both introduction points and
                  exact polymorphic types are to be specified.  However, the
                  elimination of polymorphic types is semi-implicit: only
                  elimination points are to be specified as polymorphic
                  types themselves are inferred.  This extension is
                  particularly useful in Objective ML where polymorphism
                  replaces subtyping.  },
  url          = {http://www.springerlink.com/content/m303472288241339/},
  hidedvi      = ftprocq # {iandc.dvi.gz},
  hideps       = ftprocq # {iandc.ps.gz},
  pdf          = ftprocq # {iandc.pdf},
  category     = journal,
}

@inproceedings{Blaudeau-Remy-Radanne/fulfilling@oopsla24,
  author       = {Blaudeau, Clément and Rémy, Didier and Radanne, Gabriel},
  title        = {Fulfilling OCaml modules with transparency},
  booktitle    = {Proceedings of the 2024 ACM International Conference on
                  Object Oriented Programming Systems Languages \&
                  Applications},
  series       = {OOPSLA '24},
  year         = {2024},
  _isbn         = {978-1-4503-2585-1},
  location     = {Pasadena, California, USA},
  _pages        = {233--249},
  _numpages     = {17},
  _url          = {http://doi.acm.org/10.1145/2660193.2660216},
  _doi          = {10.1145/2660193.2660216},
  _acmid        = {2660216},
  publisher    = {ACM},
  address      = {New York, NY, USA},
  _keywords     = {calculus, dependent types, objects},
}

@Unpublished{White/polyparams@ml2023,
  author       = {Leo White},
  title        = {Semi-explicit polymorphic parameters},
  note         = {Presentation at the {H}igher-order, {T}yped, {I}nferred,
                  {S}trict: {ML} Family workshops},
  month     = {sep},
  year      = {2023},
}

@inproceedings{Leroy/applicative@popl1995,
	address =			 {San Francisco, California, United States},
	title =				 {Applicative functors and fully transparent higher-order
                  modules},
	isbn =				 {978-0-89791-692-9},
	url =					 {http://portal.acm.org/citation.cfm?doid=199448.199476},
	doi =					 {10.1145/199448.199476},
	abstract =		 {We present a variant of the Standard ML module system where
                  parameterized abstract types (i.e. functors returning
                  generative types) map provably equal arguments to compatible
                  abstract types, instead of generating distinct types at each
                  application as in Standard ML. This extension solves the full
                  transparency problem (how to give syntactic signatures for
                  higher-order functors that express exactly their propagation
                  of type equations), and also provides better support for
                  non-closed code fragments.},
	language =		 {en},
	urldate =			 {2021-02-11},
	booktitle =		 {Proceedings of the 22nd {ACM} {SIGPLAN}-{SIGACT} symposium on
                  {Principles} of programming languages - {POPL} '95},
	publisher =		 {ACM Press},
	author =			 {Leroy, Xavier},
	year =				 1995,
	pages =				 {142--153},
	file =				 {Leroy - 1995 - Applicative functors and fully transparent
                  higher-.pdf:/Users/remy/Zotero/storage/P8CZWZPW/Leroy - 1995 -
                  Applicative functors and fully transparent
                  higher-.pdf:application/pdf}
}

@Misc{Pxeger-Vlasits-White-Yallop/repo-impl@github,
  author       = {Patrick Reader and Daniel Vlasits and Leo White and Jeremy
                  Yallop},
  title        = {A repository of modular implicits packages},
  url          = {https://github.com/modular-implicits/modular-implicits-opam},
  year         = 2024
}

@Misc{Pxeger-Vlasits/modular-implicits@internship2024,
  author       = {Patrick Reader and Daniel Vlasits},
  title        = {Modular Implicits internship report},
  url          = {https://github.com/modular-implicits.github.io/report.pdf},
  year         = 2024
}

@Misc{Vivien/module-type-arguments,
  author    = {Samuel Vivien},
  title     = {Type arguments from modules},
  howpublished = {On github \url {https://github.com/ocaml/RFCs/blob/27e94773c6b191a372ade263195dade779132dc2/rfcs/type_arguments_for_modules.md}},
  note      = {OCaml RFC},
  year      = 2024,
  month     = jun,
  }

@Misc{Vivien/modular-explicits,
  author    = {Samuel Vivien},
  title     = {Modular explicits},
  url       = {https://github.com/samsa1/modular-compiler-variantshttps://github.com/samsa1/modular-compiler-variants},
  note      = {Available as an OCaml variant on github},
  year      = 2024,
  month     = jun,
  }

@Misc{Ryan/modular-explicits,
  author    = {Matthew Ryan},
  title     = {Modular explicits},
  howpublished = {On github \url{https://github.com/ocaml/ocaml/pull/9187}},
  note      = {OCaml pull request},
  year      = 2019,
  month     = dec,
  }


@inproceedings{Garrigue-LeNormand/GADTs,
  title={GADTs and Exhaustiveness: Looking for the Impossible},
  author={Jacques Garrigue and Jacques Le Normand},
  booktitle={ML Family/OCaml},
  year={2017},
  url={https://api.semanticscholar.org/CorpusID:10817992}
}

@Unpublished{Vivien-Remy/explicits@ocaml2024,
  author       = {Samuel Vivien and Didier Rémy and Thomas Refis and Gabriel
                  Scherer},
  title        = {On the design and implementation of Modular Explicits},
  note         = {Presentation given at the OCaml Users and Developers
                  Workshop 2024}, 
  url          = {https://gallium.inria.fr/~remy/ocamod/modular-explicits.pdf},
  month     = {July},
  year      = 2024}

     
@Unpublished{Vivien-Remy-Refis-Scherer/explicits@2024,
  author       = {Samuel Vivien and Didier Rémy and Thomas Refis and Gabriel
                  Scherer},
  title        = {On the design and implementation of Modular Explicits},
  note         = {Draft},
  url          = {https://gallium.inria.fr/~remy/ocamod/modular-explicits.pdf},
  month     = {July},
  year      = 2024}

@article{Dunfield-Krishnaswami/bidirectional-typing,
  author       = {Dunfield, Jana and Krishnaswami, Neel},
  title        = {Bidirectional Typing},
  year         = {2021},
  issue_date   = {June 2022},
  publisher    = {Association for Computing Machinery},
  address      = {New York, NY, USA},
  volume       = {54},
  number       = {5},
  issn         = {0360-0300},
  url          = {https://doi.org/10.1145/3450952},
  doi          = {10.1145/3450952},
  abstract     = {Bidirectional typing combines two modes of typing: type
                  checking, which checks that a program satisfies a known
                  type, and type synthesis, which determines a type from the
                  program. Using checking enables bidirectional typing to
                  support features for which inference is undecidable; using
                  synthesis enables bidirectional typing to avoid the large
                  annotation burden of explicitly typed languages. In
                  addition, bidirectional typing improves error locality. We
                  highlight the design principles that underlie
                  bidirectional type systems, survey the development of
                  bidirectional typing from the prehistoric period before
                  Pierce and Turner’s local type inference to the present
                  day, and provide guidance for future investigations.},
  journal      = {ACM Comput. Surv.},
  month        = may,
  articleno    = {98},
  numpages     = {38},
  keywords     = {type inference, Type checking}
}

  
@article{Wells/SystemF-undecidable,
  title        = {Typability and type checking in System F are equivalent
                  and undecidable},
  journal      = {Annals of Pure and Applied Logic},
  volume       = {98},
  number       = {1},
  pages        = {111-156},
  year         = {1999},
  issn         = {0168-0072},
  doi          = {https://doi.org/10.1016/S0168-0072(98)00047-5},
  url          =
                  {https://www.sciencedirect.com/science/article/pii/S0168007298000475},
  author       = {J.B. Wells},
  keywords     = {System F, Semi-unification, Type inference, Typability,
                  Type checking, Lambda calculus},
  abstract     = {Girard and Reynolds independently invented System F
                  (a.k.a. the second-order polymorphically typed lambda
                  calculus) to handle problems in logic and computer
                  programming language design, respectively. Viewing F in
                  the Curry style, which associates types with untyped
                  lambda terms, raises the questions of typability and type
                  checking. Typability asks for a term whether there exists
                  some type it can be given. Type checking asks, for a
                  particular term and type, whether the term can be given
                  that type. The decidability of these problems has been
                  settled for restrictions and extensions of F and related
                  systems and complexity lower-bounds have been determined
                  for typability in F, but this report is the first to
                  resolve whether these problems are decidable for System
                  F. This report proves that type checking in F is
                  undecidable, by a reduction from semi-unification, and
                  that typability in F is undecidable, by a reduction from
                  type checking. Because there is an easy reduction from
                  typability to type checking, the two problems are
                  equivalent. The reduction from type checking to typability
                  uses a novel method of constructing lambda terms that
                  simulate arbitrarily chosen type environments. All of the
                  results also hold for the λI-calculus.}
}


@PhdThesis{Henglein/phd,
  title        = {Polymorphic Type Inference and Semi-Unification},
  author       = {Henglein, Fritz},
  school       = {New York University},
  year         = 1989,
  language     = {en},
  type         = {PhD},
  month        = {August},
}




@inproceedings{Henglein/lfp88,
  author       = {Henglein, Fritz},
  title        = {Type inference and semi-unification},
  year         = {1988},
  isbn         = {089791273X},
  publisher    = {Association for Computing Machinery},
  address      = {New York, NY, USA},
  url          = {https://doi.org/10.1145/62678.62701},
  doi          = {10.1145/62678.62701},
  abstract     = {The Milner Calculus is the typed λ-calculus underlying the
                  type system for the programming language ML [Har86] and
                  several other strongly typed polymorphic functional
                  languages such as Miranda [Tur86] and SPS [Wan84]. Mycroft
                  [Myc84] extended the problematical typing rule for
                  recursive definitions and proved that the resulting
                  calculus, termed Milner-Mycroft Calculus here, is sound
                  with respect to Milner's [Mil78] semantics and that it
                  preserves the principal typing property [DM82] of the
                  Milner Calculus. The extension is of practical
                  significance in typed logic programming languages [MO84]
                  and, more generally, in any language with (mutually)
                  recursive definitions.Mycroft didn't solve the
                  decidability problem for typings in this calculus,
                  though. This was an open problem independently raised also
                  by Meertens [Mee83]. The decidability question was
                  answered in the affirmative just recently by Kfoury et
                  al. in [KTU88]. We show that the type inference problems
                  in the Milner and the Milner-Mycroft Calculi can be
                  reduced to solving equations and inequations between
                  first-order terms, a problem we have termed
                  semi-unification. We show that semi-unification problems
                  have most general solutions in analogy to unification
                  problems — which translates into principal typing
                  properties for the underlying calculi. In contrast to the
                  (essentially) nonconstructive methods of [KTU88] we
                  present functional specifications, which we prove
                  partially correct, for computing the most general solution
                  of semi-unification problems, and we devise a concrete
                  nondeterministic algorithm on a graph-theoretic
                  representation for computing these most general
                  solutions. Finally, we point out some erroneous statements
                  about the efficiency of polymorphic type checking that
                  have persisted throughout the literature including an
                  incorrect claim, submitted by ourselves, of polynomial
                  time type checking in the Milner-Mycroft Calculus.},
  booktitle    = {Proceedings of the 1988 ACM Conference on LISP and
                  Functional Programming},
  pages        = {184–197},
  numpages     = {14},
  location     = {Snowbird, Utah, USA},
  series       = {LFP '88}
}

@article{Kapur-Musser-Narendran-Stillman/tcs1991,
  title        = {Semi-unification},
  volume       = {81},
  ISSN         = {0304-3975},
  DOI          = {https://doi.org/10.1016/0304-3975(91)90189-9},
  abstractNote = {Semi-unification is a generalization fo both matching and
                  ordinary unification: for a given pair of terms s and t,
                  two substitution Ï and Ï are sought such that
                  Ï(Ï(s))=Ï(t). Semi-unifiability can be used as
                  a check for non-termination of a rewrite rule, but
                  constructing a correct semi- unification algorithm has
                  been an elusive goal; for example, an algorithm given by
                  Purdom in his RTA-87 paper was incorrect. This paper
                  presents a decision procedure for semi-unification based
                  on techniques semilar to those used in the Knuth-Bendix
                  completion procedure. When its substitutions Ï and
                  Ï are easily extracted. Though exponential in its
                  computing time, the decision procedure can be improved to
                  a polynomial-time algorithm, as will be shown.},
  number       = {2},
  journal      = {Theoretical Computer Science},
  author       = {Kapur, Deepak and Musser, David and Narendran, Paliath and
                  Stillman, Jonathan},
  year         = {1991},
  pages        = {169--187}
}

@article{Kfoury-Tiuryn-Urzyczyn/ic1993,
  title        = {The Undecidability of the Semi-unification Problem},
  volume       = {102},
  ISSN         = {0890-5401},
  DOI          = {https://doi.org/10.1006/inco.1993.1003},
  abstractNote = {The Semi-Unification Problem (SUP) is a natural
                  generalization of both first-order unification and
                  matching. The problem arises in various branches of
                  computer science and logic. Although several special cases
                  of SUP are known to be decidable, the problem in general
                  has been open for several years. We show that SUP in
                  general is undecidable, by reducing what we call the
                  boundedness problem of Turing machines
                  to SUP. The undecidability of this boundedness problem is
                  established by a technique developed in the mid-1960s to
                  prove related results about Turing machines},
  number       = {1},
  journal      = {Information and Computation},
  author       = {Kfoury, A. J. and Tiuryn, J. and Urzyczyn, P.},
  year         = {1993},
  pages        = {83--101}
}

@inproceedings{Lushman-Cormack/ppdp2007,
  address      = {New York, NY, USA},
  series       = {PPDP '07},
  title        = {A Larger Decidable Semiunification Problem},
  ISBN         = {978-1-59593-769-8},
  url          = {http://doi.acm.org/10.1145/1273920.1273939},
  DOI          = {10.1145/1273920.1273939},
  note         = {event-place: Wroclaw, Poland},
  booktitle    = {Proceedings of the 9th ACM SIGPLAN International
                  Conference on Principles and Practice of Declarative
                  Programming},
  publisher    = {ACM},
  author       = {Lushman, Brad and Cormack, Gordon V.},
  year         = {2007},
  pages        = {143--152},
  collection   = {PPDP'07}
}

@unpublished{Lushman-Cormack/draft2006,
  title        = {The R-Acyclic Semiunification Problem},
  abstractNote = {We recast Kfoury and Wells etal's formulation of the
                  acyclic semiunification problem (ASUP) in
                  graphtheoretic terms and prove equivalence between the two
                  formulations. We then relax and simplify the
                  graph-theoretic formulation; we call the resulting problem
                  the R-acyclic semiunification problem (RASUP), which
                  we show to be a strict superset of ASUP. We prove that the
                  ASUP solution procedure terminates and produces most
                  general solutions for R-ASUP (and hence for ASUP) in the
                  same sense as Robinson etal's unification algorithm. We
                  thus extend the class of semiunification instances
                  known to be decidable.},
  author       = {Lushman, Brad and Cormack, Gordon V},
  language     = {en},
  url          = {https://cs.uwaterloo.ca/research/tr/2006/CS-2006-06.pdf}
}

@inproceedings{McAllester/rta2003,
  address      = {Berlin, Heidelberg},
  series       = {RTA'03},
  title        = {A logical algorithm for ML type inference},
  ISBN         = {3-540-40254-3},
  abstractNote = {This paper gives a bottom-up logic programming formulation
                  of the Hindley-Milner polymorphic type inference
                  algorithm. We show that for programs of bounded order and
                  arity the given algorithm runs in O(nÎ±(n) + dn) time
                  where n is the length of the program, d is the
                  âscheme depthâ of the program, and Î± is
                  the inverse of Ackermannâs function. It is argued
                  that for practical programs d will not exceed 5 even for
                  programs with hundreds of module layers. This formulation
                  of the Hindley-Milner algorithm is intended as a case
                  study in âlogical algorithmsâ, i.e.,
                  algorithms presented and analyzed as bottom-up inference
                  rules.},
  note         = {event-place: Valencia, Spain},
  booktitle    = {Proceedings of the 14th International Conference on
                  Rewriting Techniques and Applications},
  publisher    = {Springer-Verlag},
  author       = {McAllester, David},
  year         = {2003},
  pages        = {436--451},
  collection   = {RTA-2003}
}

@inproceedings{Kanellakis-Mitchell/popl1989,
  author       = {Kanellakis, P. C. and Mitchell, J. C.},
  title        = {Polymorphic unification and ML typing},
  address      = {New York, NY, USA},
  booktitle    = {Proceedings of the 16th ACM SIGPLAN-SIGACT Symposium on
                  Principles of Programming Languages},
  series       = {POPL ’89},
  ISBN         = {0-89791-294-2},
  url          = {https://doi.org/10.1145/75277.75286},
  DOI          = {10.1145/75277.75286},
  abstractNote = {We study the complexity of type inference for a core
                  fragment of ML with lambda abstraction, function
                  application, and the polymorphic let declaration. Our
                  primary technical tool is the unification problem for a
                  class of “polymorphic” type expressions. This form of
                  unification, which we call polymorphic unification, allows
                  us to separate a combinatorial aspect of type inference
                  from the syntax of ML programs. After observing that ML
                  typing is in DEXPTIME, we show that polymorphic
                  unification is PSPACE hard. From this, we prove that
                  recognizing the typable core ML programs is also PSPACE
                  hard. Our lower bound stands in contrast to the common
                  belief that typing ML programs is “efficient,” and to
                  practical experience which suggests that the algorithms
                  commonly used for this task do not slow compilation
                  substantially.},
  note         = {event-place: Austin, Texas, USA},
  publisher    = {Association for Computing Machinery},
  year         = {1989},
  pages        = {105–115},
  collection   = {POPL ’89}
}

@incollection{Kanellakis-Mairson-Mitchell/essay1991,
  Author       = "Kanellakis, P.C. and Mairson, H.G. and Mitchell, J.C.",
  Title        = "Unification and {ML} type reconstruction",
  Booktitle    = "Computational Logic, Essays in Honor of {Alan Robinson}",
  Year         = "1991",
  pages        = "444--478",
  publisher    = "MIT Press",
  editors      = "J.-L. Lassex and G.D. Plotkin"
}
        
@inProceedings{Kanellakis-Mitchell/popl89,
  Author       = "Kanellakis, P.C. and Mitchell, J.C.",
  Title        = "Polymorphic unification and {ML} typing",
  Booktitle    = "16th ACM Symposium on Principles of Programming Languages",
  Year         = "1989",
  pages        = "105-115",
  abstractNote = {We study the complexity of type reconstruction for a core
                  fragment of ML with lambda abstraction, function
                  application, and the polymorphic let declaration. We
                  derive exponential upper and lower bounds on recognizing
                  the typable core ML expressions. Our primary technical
                  tool is uni cation of succinctly represented type
                  expressions. After observing that core ML expressions, of
                  size n, can be typed in DTIME(2n), we exhibit two di erent
                  families of programs whose principal types grow
                  exponentially. We show how to exploit the expressiveness
                  of the let-polymorphism in these constructions to derive
                  lower bounds on deciding typability: one leads naturally
                  to NP-hardness and the other to DTIME(2nk)-hardness for
                  each integer k 1. Our generic simulation of any
                  exponential time Turing Machine by ML type reconstruction
                  may be viewed as a nonstandard way of computing with
                  types. Our worst-case lower bounds stand in contrast to
                  practical experience, which suggests that commonly used
                  algorithms for type reconstruction do not slow compilation
                  substantially.},
  author       = {Mitchell, John C},
  language     = {en}
}

@article{Oliart_Snyder_2004,
  title        = {Fast algorithms for uniform semi-unification},
  volume       = {37},
  ISSN         = {0747-7171},
  DOI          = {https://doi.org/10.1016/j.jsc.2003.03.002},
  abstractNote = {Uniform semi-unification is a simple combination of
                  matching and unification defined as follows: given two
                  terms s and t, do there exist substitutions Ï and
                  Ï such that sÏÏ=tÏ? We present two
                  algorithms for this problem based on Huetâs
                  unification closure method, one producing (possibly)
                  non-principal solutions, and one producing principal
                  solutions. For both we provide a precise analysis of
                  correctness and asymptotic complexity. Under the uniform
                  cost RAM model (counting assignment, comparison, and
                  arithmetic operations as primitive) our first algorithm is
                  asymptotically as fast as Huetâs method,
                  O(nÎ±(n)), where Î± is the functional inverse of
                  Ackermannâs function. Under a model which counts
                  assignments and comparisons of pointers, and arithmetic
                  operations on bits, the cost is O(n2Î±(n)2). Producing
                  principal solutions is more complex, however, and our
                  second algorithm runs in O(n2Î±(n)2) and
                  O(n2log2(nÎ±(n))loglog(nÎ±(n))Î±(n)2) under these two
                  models.},
  number       = {4},
  journal      = {Journal of Symbolic Computation},
  author       = {Oliart, Alberto and Snyder, Wayne},
  year         = {2004},
  pages        = {455--484}
}

@article{Selsam-Ullrich-Moura/2020,
  title        = {Tabled Typeclass Resolution},
  url          = {http://arxiv.org/abs/2001.04301},
  DOI          = {10.48550/arXiv.2001.04301},
  abstractNote = {Typeclasses provide an elegant and eï¬ective way of
                  managing ad-hoc polymorphism in both programming languages
                  and interactive proof assistants. However, the
                  increasingly sophisticated uses of typeclasses within
                  proof assistants, especially within Leanâs
                  burgeoning mathematics library, mathlib, have elevated
                  once-theoretical limitations of existing typeclass
                  resolution procedures into major impediments to ongoing
                  progress. The two most devastating limitations of existing
                  procedures are exponential running times in the presence
                  of diamonds and divergence in the presence of cycles. We
                  present a new procedure, tabled typeclass resolution, that
                  solves both problems by tabling, which is a generalization
                  of memoizing originally introduced to address similar
                  limitations of early logic programming systems. We have
                  implemented our procedure for the upcoming version (v4) of
                  Lean, and have confirmed empirically that our
                  implementation is exponentially faster than existing
                  systems in the presence of diamonds. Although tabling is
                  notoriously diï¬cult to implement, our procedure is
                  notably lightweight and could easily be implemented in
                  other systems. We hope our new procedure facilitates even
                  more sophisticated uses of typeclasses in both software
                  development and interactive theorem proving.},
  note         = {arXiv:2001.04301 [cs]},
  number       = {arXiv:2001.04301},
  publisher    = {arXiv},
  author       = {Selsam, Daniel and Ullrich, Sebastian and Moura, Leonardo
                  de},
  year         = {2020},
  month        = jan,
  language     = {en}
}

@Article{Vasconcellos-Figueiredo-Camarao/jucs2003,
  author       = {Cristiano Vasconcellos and Luc{\'i}lia Figueiredo and
                Carlos Camar{\tilde{a}}},
  title        = {Practical Type Inference for Polymorphic Recursion: an
                  Implementation in Haskell},
  journal      = {Journal of Universal Computer Science},
  year         = {2003},
  volume    = 9,
  number    = 8,
  abstractNote = {This paper describes a practical type inference algorithm
                  for typing polymorphic and possibly mutually recursive
                  definitions, using Haskell to provide a highlevel
                  implementation of the algorithm.},
}

@InProceedings{Chargueraud-Bodin-Dunfield-Riboulet/jfla2025,
  author       = {Charguéraud, Arthur and Bodin, Martin and Dunfield, Jana
                  and Riboulet, Louis},
  title        = {Typechecking of Overloading},
  booktitle = {Journées Francophones des Langages Applicatifs},
  year      = 2025,
  month     = jan,
}

@InCollection{Pottier-Remy/emlti,
  author       = {Fran{\c{c}}ois Pottier and Didier R{\'{e}}my},
  title        = {The Essence of {ML} Type Inference},
  booktitle    = {Advanced Topics in Types and Programming Languages},
  pages        = {389--489},
  publisher    = {MIT Press},
  year         = {2005},
  editor       = {Benjamin C. Pierce},
  chapter      = {10},
  url          = {https://pauillac.inria.fr/~remy/attapl/},
  category     = bookchapter,
}


@phdthesis{Remy/thesis,
  author       = "Didier R{\'e}my",
  title        = "Alg{\`e}bres Touffues. Application au Typage Polymorphe
                  des Objets Enregistrements dans les Langages Fonctionnels",
  type         = "Th{\`e}se de doctorat",
  school       = "Universit{\'e} de Paris~7",
  year         = 1990,
  hideps       = ftprocq # {these.ps.gz},
  pdf          = ftprocq # {these.pdf},
  category     = dissertation,
}

@TechReport{Remy/start,
  author       = "Didier R{\'e}my",
  title        = "Syntactic Theories and the Algebra of Record Terms",
  institution  = "Institut National de Recherche en Informatique et
                  Automatisme",
  address      = "Rocquencourt, BP 105, 78 153 Le Chesnay Cedex, France",
  type         = "Research Report",
  number       = 1869,
  year         = 1993,
  category     = researchreport,
  abstract     = { Many type systems for records have been proposed. For
                  most of them, the types cannot be described as the terms
                  of an algebra. In this case, type checking, or type
                  inference in the case of first order type systems, cannot
                  be derived from existing algorithms. We define record
                  terms as the terms of an equational algebra. We prove
                  decidability of the unification problem for records terms
                  by showing that its equational theory is syntactic. We
                  derive a complete algorithm and prove its termination. We
                  define a notion of canonical terms and approximations of
                  record terms by canonical terms, and show that
                  approximations commute with unification. We also study
                  generic record terms, which extend record terms to model a
                  form of sharing between terms. We prove the syntacticness
                  of the equational theory of generic record terms and the
                  termination of the corresponding unification algorithm.  },
  hidedvi      = ftprocq # {record-algebras.dvi.gz},
  hideps       = ftprocq # {record-algebras.ps.gz},
  pdf          = ftprocq # {record-algebras.pdf}
}

@Misc{Kiselyov/ranks@blog2022,
  author    = {Oleg Kiselyov},
  title     = {How OCaml type checker works -- or what polymorphism and
               garbage collection have in common},
  url       = {https://okmij.org/ftp/ML/generalization.html},
  month     = jan,
  year      = 2022,
  note      = {Blog Post}}

@inproceedings{Kfoury-Wells/lfp94,
  author       = {A. J. Kfoury and J. B. Wells},
  editor       = {Robert R. Kessler},
  title        = {A Direct Algorithm for Type Inference in the Rank-2
                  Fragment of the Second-Order lambda-Calculus},
  booktitle    = {Proceedings of the 1994 {ACM} Conference on {LISP} and
                  Functional Programming, Orlando, Florida, USA, 27-29 June
                  1994},
  pages        = {196--207},
  publisher    = {{ACM}},
  year         = {1994},
  url          = {https://doi.org/10.1145/182409.182456},
  doi          = {10.1145/182409.182456},
  timestamp    = {Fri, 06 Aug 2021 15:08:55 +0200},
  biburl       = {https://dblp.org/rec/conf/lfp/KfouryW94.bib},
  bibsource    = {dblp computer science bibliography, https://dblp.org}
}

@article{Chen-Erwig-Walkingshaw/variational@toplas2014,
  title        = {Extending Type Inference to Variational Programs},
  volume       = {36},
  ISSN         = {0164-0925, 1558-4593},
  DOI          = {10.1145/2518190},
  abstractNote = {Through the use of conditional compilation and related
                  tools, many software projects can be used to generate a
                  huge number of related programs. The problem of typing
                  such variational software is difficult. The brute-force
                  strategy of generating all variants and typing each one
                  individually is: (1) usually infeasible for efficiency
                  reasons and (2) produces results that do not map well to
                  the underlying variational program. Recent research has
                  focused mainly on efficiency and addressed only the
                  problem of type checking. In this work we tackle the more
                  general problem of variational type inference and
                  introduce variational types to represent the result of
                  typing a variational program. We introduce the variational
                  lambda calculus (VLC) as a formal foundation for research
                  on typing variational programs. We define a type system
                  for VLC in which VLC expressions are mapped to
                  correspondingly variational types. We show that the type
                  system is correct by proving that the typing of
                  expressions is preserved over the process of variation
                  elimination, which eventually results in a plain lambda
                  calculus expression and its corresponding type. We
                  identify a set of equivalence rules for variational types
                  and prove that the type unification problem modulo these
                  equivalence rules is unitary and decidable; we also
                  present a sound and complete unification algorithm. Based
                  on the unification algorithm, the variational type
                  inference algorithm is an extension of algorithm W . We
                  show that it is sound and complete and computes principal
                  types. We also consider the extension of VLC with sum
                  types, a necessary feature for supporting variational data
                  types, and demonstrate that the previous theoretical
                  results also hold under this extension. Finally, we
                  characterize the complexity of variational type inference
                  and demonstrate the efficiency gains over the brute-force
                  strategy.},
  number       = {1},
  journal      = {ACM Transactions on Programming Languages and Systems},
  author       = {Chen, Sheng and Erwig, Martin and Walkingshaw, Eric},
  year         = {2014},
  month        = mar,
  pages        = {1–54},
  language     = {en}
}


@InProceedings{Vasconcellos-Figueiredo-Camarao/polyrec@sblp2003,
  title        = {Practical Type Inference for Polymorphic Recursion: an
                  Implementation in Haskell},
  abstract     = {This paper describes a practical type inference algorithm
                  for typing polymorphic and possibly mutually recursive
                  deﬁnitions, using Haskell to provide a high-level
                  implementation of the algorithm.},
  author       = {Vasconcellos, Cristiano and Figueiredo, Luc{\'i}lia and
                  Camarao, Carlos},
  booktitle = {7th Brazilian Symposium on Programming Languages},
  year      = {2003},
  series    = {SBLP},
  month     = {May},
  }

@article{Xue-Oliveira/contextual-typing@icfp2024,
  title        = {Contextual Typing},
  volume       = {8},
  ISSN         = {2475-1421},
  DOI          = {10.1145/3674655},
  abstractNote = {Bidirectional typing is a simple, lightweight approach to
                  type inference that propagates known type information
                  during typing, and can scale up to many diﬀerent type
                  systems and features. It typically only requires a
                  reasonable amount of annotations and eliminates the need
                  for many obvious annotations. Nonetheless the power of
                  inference is still limited, and complications arise in the
                  presence of more complex features. In this paper we
                  present a generalization of bidirectional typing called
                  contextual typing. In contextual typing not only known
                  type information is propagated during typing, but also
                  other known information about the surrounding context of a
                  term. This information can be of various forms, such as
                  other terms or record labels. Due to this richer notion of
                  contextual information, less annotations are needed, while
                  the approach remains lightweight and scalable. For type
                  systems with subtyping, contextual typing subsumption is
                  also more expressive than subsumption with bidirectional
                  typing, since partially known contextual information can
                  be exploited. To aid specifying type systems with
                  contextual typing, we introduce Quantitative Type
                  Assignment Systems (QTASs). A QTAS quantiﬁes the amount of
                  type information that a term needs in order to type check
                  using counters. Thus, a counter in a QTAS generalizes
                  modes in traditional bidirectional typing, which can only
                  model an all (checking mode) or nothing (inference mode)
                  approach. QTASs enable precise guidelines for
                  annotatability of contextual type systems formalized as a
                  theorem. We illustrate contextual typing ﬁrst on a simply
                  typed lambda calculus, and then on a richer calculus with
                  subtyping, intersection types, records and
                  overloading. All the metatheory is formalized in the Agda
                  theorem prover. CCS Concepts: • Theory of computation →
                  Type theory.},
  number       = {ICFP},
  journal      = {Proceedings of the ACM on Programming Languages},
  author       = {Xue, Xu and Oliveira, Bruno C. D. S.},
  year         = {2024},
  month        = aug,
  pages        = {880–908},
  url          = {https://dl.acm.org/doi/pdf/10.1145/3674655},
  language     = {en}
}

@article{Vytiniotis-Peyton-Jones-Schrijvers-Sulzmann/outsidein@jfp2011,
  author       = {Dimitrios Vytiniotis and
                  Simon L. Peyton Jones and
                  Tom Schrijvers and
                  Martin Sulzmann},
  title        = {OutsideIn(X) Modular type inference with local assumptions},
  journal      = {J. Funct. Program.},
  volume       = {21},
  number       = {4-5},
  pages        = {333--412},
  year         = {2011},
  url          = {https://doi.org/10.1017/S0956796811000098},
  doi          = {10.1017/S0956796811000098},
  biburl       = {https://dblp.org/rec/journals/jfp/VytiniotisJSS11.bib},
}

@article{Odersky-Sulzmann-Wehr@tpos,
  title        = {Type inference with constrained types},
  volume       = {5},
  ISSN         = {1096-9942},
  DOI          = {10.1002/(SICI)1096-9942(199901/03)5:1<35::AID-TAPO4>3.0.CO;2-4},
  abstractNote = {We present a general framework HM(X) for type systems with
                  constraints. The framework stays in the tradition of the
                  Hindley/Milner type system. Its type system instances are
                  sound under a standard untyped compositional semantics. We
                  can give a generic type inference algorithm for HM(X) so
                  that, under sufficient conditions on X, type inference
                  will always compute the principal type of a term. We
                  discuss instances of the framework that deal with
                  polymorphic records, equational theories, and subtypes. Â©
                  1999 John Wiley & Sons, Inc.},
  number       = {1},
  journal      = {Theory and Practice of Object Systems},
  author       = {Odersky, Martin and Sulzmann, Martin and Wehr, Martin},
  year         = {1999},
  pages        = {35--55},
  language     = {en}
}

@inproceedings{Pottier-Regis-Gianas/stratified@popl06,
  author       = {François Pottier and Yann Régis-Gianas},
  title        = {Stratified type inference for generalized algebraic data
                  types},
  booktitle    = {Principles of Programming Languages ({POPL})},
  month        = jan,
  year         = {2006},
  pages        = {232--244},
  url          = {http://cambium.inria.fr/~fpottier/publis/pottier-regis-gianas-popl06.pdf}
}

@article{Lee_Yi/algoM@toplas1998,
  title        = {Proofs about a folklore let-polymorphic type inference
                  algorithm},
  volume       = {20},
  ISSN         = {0164-0925, 1558-4593},
  DOI          = {10.1145/291891.291892},
  abstractNote = {The Hindley/Milner let-polymorphic type inference system
                  has two different algorithms: one is the de facto standard
                  Algorithm W that is bottom-up (or context-insensitive),
                  and the other is a ``folkloren'' algorithm that is
                  top-down (or context-sensitive). Because the latter
                  algorithm has not been formally presented with its
                  soundness and completeness proofs, and its relation with
                  the W algorithm has not been rigorously investigated, its
                  use in place of (or in combination with) W is not well
                  founded. In this article, we formally define the
                  context-sensitive, top-down type inference algorithm
                  (named ``M''), prove its soundness and completeness, and
                  show a distinguishing property that M always stops earlier
                  than W if the input program is ill typed. Our proofs can
                  be seen as theoretical justifications for various
                  type-checking strategies being used in practice.},
  number       = {4},
  journal      = {ACM Transactions on Programming Languages and Systems},
  author       = {Lee, Oukseh and Yi, Kwangkeun},
  year         = {1998},
  month        = jul,
  pages        = {707–723},
  language     = {en}
}

@techreport{Remy/mleth,
  author       = {Didier R{\'e}my},
  title        = {Extending {ML} Type System with a Sorted Equational
                  Theory},
  institution  = {Institut National de Recherche en Informatique et
                  Automatisme},
  address      = {Rocquencourt, BP 105, 78 153 Le Chesnay Cedex, France},
  type         = {Research Report},
  number       = 1766,
  year         = 1992,
  category     = {D},
  abstract     = { We extend the ML language by allowing a sorted regular
                  equational theory on types for which unification is
                  decidable and unitary. We prove that the extension keeps
                  principal typings and subject reduction. A new set of
                  typing rules is proposed so that type generalization is
                  simpler and more efficient. We consider typing problems as
                  general unification problems, which we solve with a
                  formalism of unificands. Unificands naturally deal with
                  sharing between types and lead to a more efficient type
                  inference algorithm. The use of unificands also simplifies
                  the proof of correctness of the algorithm by splitting it
                  into more elementary steps.  },
  hidedvi      =
                  {http://cambium.inria.fr/~remy/ftp/eq-theory-on-types.dvi.gz},
  hideps       =
                  {http://cambium.inria.fr/~remy/ftp/eq-theory-on-types.ps.gz},
  pdf          = {http://cambium.inria.fr/~remy/ftp/eq-theory-on-types.pdf}
}

@InProceedings{Gauthier-Pottier/numbering@icfp04,
  author       = "Nadji Gauthier and Fran\c{c}ois Pottier",
  title        = "Numbering Matters: First-Order Canonical Forms for
                 Second-Order Recursive Types",
  booktitle    = icfp,
  URL          = "http://cambium.inria.fr/~fpottier/publis/gauthier-fpottier-icfp04.pdf",
  month        = sep,
  year         = "2004",
  pages        = "150--161",
}

@inproceedings{Leijen-Ye/prefix@pldi2025,
  title        = {Principal Type Inference under a Prefix},
  url          =
                  {https://www.microsoft.com/en-us/research/publication/principal-type-inference-under-a-prefix/},
  abstractNote = {At the heart of the Damas-Hindley-Milner (HM) type system
                  lies the abstraction rule which derives a function type
                  for a lambda expression. In this rule, the type of the
                  parameter can be “guessed”, and can be any type that fits
                  the derivation. The beauty of the HM system is that there
                  always exists a most general type that encompasses all
                  possible derivations – Algorithm W is used to infer these
                  most general types in practice. Unfortunately, this
                  property is also the bane of the HM type rules. Many
                  languages extend HM typing with additional features which
                  often require complex side conditions to the type rules to
                  maintain principal types. For example, various type
                  systems for impredicative type inference, like HMF,
                  FreezeML, or Boxy types, require let-bindings to always
                  assign most general types. Such a restriction is difficult
                  to specify as a logical deduction rule though, as it
                  ranges over all possible derivations. Despite these
                  complications, the actual implementations of various type
                  inference algorithms are usually straightforward
                  extensions of algorithm W, and from an implementation
                  perspective, much of the complexity of various type system
                  extensions, like boxes or polymorphic weights, is in some
                  sense artificial. In this article we rephrase the HM type
                  rules as _type inference under a prefix_, called HMQ. HMQ
                  is sound and complete with respect to the HM type rules,
                  but always derives principal types that correspond to the
                  types inferred by algorithm W. The HMQ type rules are
                  close to the clarity of the declarative HM type rules, but
                  also specific enough to “read off” an inference algorithm,
                  and can form an excellent basis to describe type system
                  extensions in practice. We show in particular how to
                  describe the FreezeML and HMF systems in terms of
                  inference under a prefix, and how we no longer require
                  complex side conditions. We also show a novel
                  formalization of static overloading in HMQ as implemented
                  in Koka language.},
  note         = {Backup Publisher: ACM SIGPLAN},
  booktitle    = {PLDI’25},
  publisher    = {ACM},
  author       = {Leijen, Daan and Ye, Wenjia},
  year         = {2025},
  month        = jun,
  pages        = {1–24}
}

@inproceedings{10.1145/3385412.3386003,
  author       = {Emrich, Frank and Lindley, Sam and Stolarek, Jan and
                  Cheney, James and Coates, Jonathan},
  title        = {FreezeML: complete and easy type inference for first-class
                  polymorphism},
  year         = {2020},
  isbn         = {9781450376136},
  publisher    = {Association for Computing Machinery},
  address      = {New York, NY, USA},
  url          = {https://doi.org/10.1145/3385412.3386003},
  doi          = {10.1145/3385412.3386003},
  abstract     = {ML is remarkable in providing statically typed
                  polymorphism without the programmer ever having to write
                  any type annotations. The cost of this parsimony is that
                  the programmer is limited to a form of polymorphism in
                  which quantifiers can occur only at the outermost level of
                  a type and type variables can be instantiated only with
                  monomorphic types.  Type inference for unrestricted System
                  F-style polymorphism is undecidable in
                  general. Nevertheless, the literature abounds with a range
                  of proposals to bridge the gap between ML and System F.
                  We put forth a new proposal, FreezeML, a conservative
                  extension of ML with two new features. First, let- and
                  lambda-binders may be annotated with arbitrary System F
                  types. Second, variable occurrences may be frozen,
                  explicitly disabling instantiation. FreezeML is equipped
                  with type-preserving translations back and forth between
                  System F and admits a type inference algorithm, an
                  extension of algorithm W, that is sound and complete and
                  which yields principal types.},
  booktitle    = {Proceedings of the 41st ACM SIGPLAN Conference on
                  Programming Language Design and Implementation},
  pages        = {423–437},
  numpages     = {15},
  keywords     = {first-class polymorphism, impredicative types, type
                  inference},
  location     = {London, UK},
  series       = {PLDI 2020}
}


@inproceedings{Damas-Milner/W@popl82,
  author       = {Damas, Luis and Milner, Robin},
  title        = {Principal type-schemes for functional programs},
  year         = {1982},
  isbn         = {0897910656},
  publisher    = {Association for Computing Machinery},
  address      = {New York, NY, USA},
  url          = {https://doi.org/10.1145/582153.582176},
  doi          = {10.1145/582153.582176},
  booktitle    = {Proceedings of the 9th ACM SIGPLAN-SIGACT Symposium on
                  Principles of Programming Languages},
  pages        = {207--212},
  numpages     = {6},
  location     = {Albuquerque, New Mexico},
  series       = {POPL '82}
}

@article{Hindley/Principal@tams1969,
    title = {The Principal Type-Scheme of an Object in Combinatory Logic},
    volume = {146},
    doi = {10.2307/1995158},
    pages = {29},
    journaltitle = {Transactions of the American Mathematical Society},
    author = {Hindley, R.},
    date = {1969},
}

@Article{LeBotlan-Remy/recasting-mlf,
  author       = {Le Botlan, Didier and R{\'{e}}my, Didier},
  title        = {Recasting {MLF}},
  journal      = {Information and Computation},
  volume       = {207},
  number       = {6},
  pages        = {726--785},
  year         = {2009},
  category     = journal,
  issn         = {0890-5401},
  doi          = {10.1016/j.ic.2008.12.006},
  url          = {http://dx.doi.org/10.1016/j.ic.2008.12.006},
  OFF          = {http://dx.doi.org/10.1016/j.ic.2008.12.006},
  PDF          = {https://hal.inria.fr/inria-00156628},
  ALSO         = {http://cambium.inria.fr/~remy/work/mlf/},
  KEYWORDS     = "ML",
  KEYWORDS     = "System F",
  KEYWORDS     = "Type inference",
  KEYWORDS     = "Type checking",
  KEYWORDS     = "Polymorphism",
  KEYWORDS     = "First-class polymorphism",
  ABSTRACT     = {The language MLF is a proposal for a new type system that
                  supersedes both ML and System F, allows for efficient,
                  predictable, and complete type inference for partially
                  annotated terms.  In this work, we revisit the definition
                  of MLF, following a more progressive approach and focusing
                  on the design-space and expressiveness.  We introduce a
                  Curry-style version iMLF of MLF and provide an
                  interpretation of iMLF types as instantiation-closed sets
                  of System-F types, from which we derive the definition of
                  type instance in iMLF.  We give equivalent syntactic
                  definition of the type-instance, presented as a set of
                  inference rules.  We also show an encoding of iMLF into
                  the closure of Curry-style System F by let-expansion.  We
                  derive the Church-style version eMLF by refining types of
                  iMLF so as to distinguish between given and inferred
                  polymorphism.  We show an embedding of ML in eMLF and a
                  straightforward encoding of System F into eMLF.}
}

@article{huet-unif,
title = {A unification algorithm for typed $\lambda$-calculus},
journal = {Theoretical Computer Science},
volume = {1},
number = {1},
year = {1975},
author = {Huet, G{\'e}rard},
abstract = {A semi-decision algorithm is presented, to search for unification of formulas in typed ω-order λ-calculus, and its correctness is proved. It is shown that the search space is significantly smaller than the one for finding the most general unifiers. In particular, our search is not redundant. This allows our algorithm to have good directionality and convergence properties.}
}

@book{jones-qualified-types,
author = {Jones, Mark P.},
title = {Qualified types: theory and practice},
year = {1995},
publisher = {Cambridge University Press},
}

@inproceedings{dunfield-krishnaswami-bidirectional-poly,
author = {Dunfield, Jana and Krishnaswami, Neelakantan R.},
title = {Complete and easy bidirectional typechecking for higher-rank polymorphism},
year = {2013},
abstract = {Bidirectional typechecking, in which terms either synthesize a type or are checked against a known type, has become popular for its scalability (unlike Damas-Milner type inference, bidirectional typing remains decidable even for very expressive type systems), its error reporting, and its relative ease of implementation. Following design principles from proof theory, bidirectional typing can be applied to many type constructs. The principles underlying a bidirectional approach to polymorphism, however, are less obvious. We give a declarative, bidirectional account of higher-rank polymorphism, grounded in proof theory; this calculus enjoys many properties such as eta-reduction and predictability of annotations. We give an algorithm for implementing the declarative system; our algorithm is remarkably simple and well-behaved, despite being both sound and complete.},
booktitle = {ICFP},
keywords = {bidirectional typechecking, higher-rank polymorphism},
}

@misc{rossberg-wasm,
  author={Andreas Rossberg},
  year=2016,
  title={WebAssembly: high speed at low cost for everyone},
  note={presented at the ML Family Workshop},
}
